- [感知机 (perceptron)](#感知机-perceptron)
  - [模型](#模型)
  - [损失函数](#损失函数)
  - [学习算法](#学习算法)
    - [算法的原始形式：](#算法的原始形式)
    - [算法的对偶形式：](#算法的对偶形式)
  - [总结](#总结)
- [支持向量机 (SVM)](#支持向量机-svm)
  - [函数间隔与几何间隔](#函数间隔与几何间隔)
  - [线性可分支持向量机](#线性可分支持向量机)
  - [线性支持向量机](#线性支持向量机)
  - [非线性支持向量机](#非线性支持向量机)
  - [核函数](#核函数)
  - [序列最小最优化算法 (SMO)](#序列最小最优化算法-smo)
  - [总结](#总结-1)
- [逻辑回归 (logistic regressive)](#逻辑回归-logistic-regressive)
  - [模型](#模型-1)
  - [模型参数估计](#模型参数估计)
  - [多项逻辑回归](#多项逻辑回归)
- [最大熵模型 (maximum entropy model)](#最大熵模型-maximum-entropy-model)
  - [最大熵原理](#最大熵原理)
  - [最大熵模型](#最大熵模型)
  - [总结](#总结-2)
- [k近邻 (k-NN)](#k近邻-k-nn)
- [聚类算法](#聚类算法)
- [朴素贝叶斯](#朴素贝叶斯)
  - [基本方法](#基本方法)
  - [参数估计](#参数估计)
- [EM算法](#em算法)
- [高斯混合模型](#高斯混合模型)
- [隐马尔可夫模型 (HMM)](#隐马尔可夫模型-hmm)
  - [概率计算算法](#概率计算算法)
  - [学习算法](#学习算法-1)
  - [预测算法](#预测算法)
- [条件随机场 (CRF)](#条件随机场-crf)
  - [概率无向图模型](#概率无向图模型)
  - [条件随机场](#条件随机场)
  - [条件随机场的概率计算问题](#条件随机场的概率计算问题)
  - [条件随机场的学习算法](#条件随机场的学习算法)
  - [条件随机场的预测算法](#条件随机场的预测算法)
- [决策树](#决策树)
  - [特征选择](#特征选择)
    - [熵](#熵)
    - [信息增益](#信息增益)
    - [信息增益比](#信息增益比)
    - [基尼指数](#基尼指数)
  - [决策树的生成](#决策树的生成)
  - [决策树的剪枝](#决策树的剪枝)
  - [分类与回归树 (CART)](#分类与回归树-cart)
- [提升方法 (boosting)](#提升方法-boosting)
  - [AdaBoost](#adaboost)
  - [提升树](#提升树)
  - [XGBoost 和 lightGBM](#xgboost-和-lightgbm)
- [Bagging和随机森林(RF)](#bagging和随机森林rf)
- [降维](#降维)
  - [奇异值分解 (SVD)](#奇异值分解-svd)
  - [主成分分析 (PCA)](#主成分分析-pca)
  - [线性判别分析 (LDA)](#线性判别分析-lda)
  - [局部线性嵌入 (LLE)](#局部线性嵌入-lle)
- [其他问题](#其他问题)
  - [生成模型与判别模型](#生成模型与判别模型)
  - [特征工程](#特征工程)
  - [最小二乘法](#最小二乘法)
  - [交叉验证](#交叉验证)
# 感知机 (perceptron)
## 模型
[感知机原理小结](https://www.cnblogs.com/pinard/p/6042320.html)  
二类分类的线性分类模型：$f(x)=\text{sign}(w\cdot x+b)$，旨在求出将训练数据进行线性划分的分离超平面。  
$$\text{sign}(x)=\left\lbrace\begin{aligned}
&+1 \quad &x\geq0 \newline  
&-1 \quad &x<0
\end{aligned}\right.$$
## 损失函数
损失函数为误分类点到分离超平面的总距离，$M$为误分类点集合：  
$$-\frac{1}{||w||}\sum_{x_i\in M}y_i(w\cdot x_i+b)$$
不考虑$-\frac{1}{||w||}$，就得到感知机学习的损失函数：  
$$L(w,b)=-\sum_{x_i\in M}y_i(w\cdot x_i+b)$$
## 学习算法
感知机学习算法是误分类驱动的，采用随机梯度下降法对损失函数进行极小化。  
### 算法的原始形式： 
$$\min_{w,b}L(w,b)=-\sum_{x_i\in M}y_i(w\cdot x_i+b)$$ 
1.选取初值 $w_0$，$b_0$  
2.在训练集中选取数据 $(x_i,y_i)$  
3.如果 $y_i(w\cdot x_i+b)\leq0$，则$w\leftarrow w+\eta y_i x_i$，$b\leftarrow b+\eta y_i$  
4.转至2，直到训练集中没有误分类点。   
### 算法的对偶形式：  
对偶形式的基本思想是，将 $w,b$ 表示为 $x_i,y_i$ 的线性组合，通过求解其系数而求得 $w,b$。假设 $w_0$，$b_0$ 均为0，对误分类点通过上面的步骤3逐步修改 $w,b$，最后学习到的 $w,b$可以分别表示为：
$$w=\sum_{i=1}^{N}\alpha_i y_i x_i$$
$$b=\sum_{i=1}^{N}\alpha_i y_i$$
$\alpha_i=n_i\eta$，当$\eta=1$时，表示第 $i$ 个实例点由于误分而更新的次数，实例点更新次数越多，说明距离分离超平面越近，越难正确分类。  
1.初值$\alpha\leftarrow0$，$b\leftarrow0$  
2.在训练集中选取数据 $(x_i,y_i)$  
3.如果 $y_i(\sum_{j=1}^{N}\alpha_j y_j x_j\cdot x_i+b)\leq0$，则$\alpha_i\leftarrow \alpha_i+\eta$，$b\leftarrow b+\eta y_i$  
4.转至2，直到训练集中没有误分类点。  
对偶形式中训练实例仅以内积的形式出现，为计算方便，可以预先将内积计算出来并以矩阵的形式存储，这个矩阵就是 Gram 矩阵。  
## 总结
简单易于实现，分为原始形式和对偶形式，是神经网络和支持向量机的基础。当训练集线性可分时，感知机学习算法收敛，存在无穷多个解（采用不同的初值或不同的迭代顺序）；线性不可分时，算法不收敛，迭代结果会发生震荡。感知机因为是线性模型，所以不能表示复杂的函数，如异或。  
# 支持向量机 (SVM)
[数据挖掘（机器学习）面试--SVM面试常考问题](https://blog.csdn.net/szlcw1/article/details/52259668)  
二类分类模型。基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；包括核技巧，使它成为实质上的非线性分类器。学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。  
标签 $y\in \{+1, -1\}$，模型 $f(x)=\text{sign}(w\cdot x+b)$。  
## 函数间隔与几何间隔
**函数间隔**：  
超平面关于样本点的函数间隔：  
$$\hat{\gamma}_i=y_i(w\cdot x_i+b)$$  
超平面关于训练集的函数间隔：  
$$\hat{\gamma}=\min_{i=1,\cdots,N}\hat{\gamma}_i$$  
**几何间隔**：  
超平面关于样本点的几何间隔：  
$$\gamma_i=\frac{y_i(w\cdot x_i+b)}{||w||}$$  
超平面关于训练集的几何间隔：  
$$\gamma=\min_{i=1,\cdots,N}\gamma_i$$  
函数间隔与几何间隔的关系：  
$$\gamma_i=\frac{\hat{\gamma_i}}{||w||}\quad\quad\gamma=\frac{\hat{\gamma}}{||w||}$$
$$$$    
## 线性可分支持向量机
硬间隔最大化。求解能够正确划分训练数据集并且间隔最大的分离超平面。线性可分训练数据集的最大间隔分离超平面存在且唯一。  
支持向量：与分离超平面距离最近的样本的，即满足 $y_i(w\cdot x_i+b)-1=0$；间隔边界间的距离：$\frac{2}{||w||}$；在决定分离超平面时只有支持向量起作用，而其他实例点不起作用。  
**原始最优化问题**：  
$$\max_{w,b}\frac{\hat{\gamma}}{||w||} \quad \quad \text{s.t.} \quad y_i(w\cdot x_i+b)\geq\hat{\gamma}$$
$$\rightarrow \quad \min_{w,b}\frac{1}{2}{||w||}^2 \quad \quad \text{s.t.} \quad y_i(w\cdot x_i+b)-1\geq0$$  
**对偶算法**：  
应用拉格朗日对偶性，通过求解对偶问题得到原始问题的最优解。  
对原始最优化问题中的每一个不等式约束引进拉格朗日乘子 $\alpha_i\geq0$，定义拉格朗日函数：  
$$L(w,b,\alpha)=\frac{1}{2}{||w||}^2-\sum_{i=1}^{N}\alpha_iy_i(w\cdot x_i+b)+\sum_{i=1}^{N}\alpha_i$$
原始问题的对偶问题是极大极小问题：
$$\max_{\alpha}\min_{w,b}L(w,b,\alpha)$$
1.求 $\min_{w,b}L(w,b,\alpha)$：  
$$\frac{\partial L}{\partial w}=w-\sum_{i=1}^{N}\alpha_iy_i x_i=0$$
$$\frac{\partial L}{\partial b}=-\sum_{i=1}^{N}\alpha_iy_i=0$$
代入得：
$$\min_{w,b}L(w,b,\alpha)=-\frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum_{i=1}^{N}\alpha_i$$
2.求 $\min_{w,b}L(w,b,\alpha)$对$\alpha$的极大，即求 $-\min_{w,b}L(w,b,\alpha)$对$\alpha$的极小，得到***对偶最优化问题***：
$$\min_{\alpha}\quad\frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i \quad\quad \text{s.t.}\quad\sum_{i=1}^{N}\alpha_iy_i=0, \quad \alpha_i\geq0$$
设 $\alpha^{\star}=({\alpha_1}^{\star},{\alpha_2}^{\star},\cdots,{\alpha_N}^{\star})^{\text T}$ 是对偶最优化问题的解，则存在下标 $j$，使得 ${\alpha_j}^{\star}>0$，并可按下式求得原始最优化问题的解：
$$w^{\star}=\sum_{i=1}^{N}{\alpha_i}^{\star}y_i x_i$$
$$b^{\star}=y_j-\sum_{i=1}^{N}{\alpha_i}^{\star}y_i(x_i\cdot x_j)$$
从而得到分离超平面：$w^{\star}\cdot x+b^{\star}=0$  
分类决策函数：$f(x)=\text{sign}(w^{\star}\cdot x+b^{\star})$
## 线性支持向量机
软间隔最大化。对近似线性可分数据，对每个样本点 $(x_i,y_i)$ 引进一个松弛变量 $\xi_i$，约束条件为 $y_i(w\cdot x_i+b)\geq1-\xi_i$，同时对每个松弛变量，支付一个代价。  
最小化目标函数包含两层含义：间隔尽量大，同时使误分类点的个数尽量小。凸二次规划问题，因而关于 $(w,b,\xi)$ 的解是存在的，可以证明 $w$ 的解唯一，而 $b$ 的解可能不唯一，而是存在一个区间。  
**原始最优化问题**：  
$$\min_{w,b,\xi}\quad\frac{1}{2}{||w||}^2+C\sum_{i=1}^N\xi_i \quad \quad \text{s.t.} \quad y_i(w\cdot x_i+b)\geq1-\xi_i, \quad \xi_i\geq0$$
**对偶算法**：   
$$\min_{\alpha}\quad\frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i \quad\quad \text{s.t.}\quad\sum_{i=1}^{N}\alpha_iy_i=0, \quad 0\leq\alpha_i\leq C$$
设 $\alpha^{\star}=({\alpha_1}^{\star},{\alpha_2}^{\star},\cdots,{\alpha_N}^{\star})^{\text T}$ 是对偶最优化问题的解，选择 $\alpha^{\star}$ 的一个分量 ${\alpha_j}^{\star}$，使得 $0<{\alpha_j}^{\star}< C$，计算：
$$w^{\star}=\sum_{i=1}^{N}{\alpha_i}^{\star}y_i x_i$$
$$b^{\star}=y_j-\sum_{i=1}^{N}{\alpha_i}^{\star}y_i(x_i\cdot x_j)$$  
求得分离超平面和分类决策函数。
## 非线性支持向量机
核技巧和软间隔最大化。  
核函数表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机，这样的方法为核技巧。  
对偶问题的目标函数中的内积 $x_i \cdot x_j$ 用核函数 $K(x_i,x_j)=\phi(x_i)\cdot\phi(x_j)$ 来代替。  
## 核函数
[SVM的核函数如何选取？](https://www.zhihu.com/question/21883548)  
**线性核函数 (Linear)**：$K(x_1,x_2)=x_1\cdot x_2$，用于线性可分的情形。参数少，速度快，对于一般数据，分类效果已经很理想了。  
**高斯核函数 (RBF)**：$K(x_1,x_2)=\exp(-\frac{||x_1-x_2||^2}{2\sigma^2})$，高斯径向基函数，主要用于线性不可分的情形。参数多，分类结果非常依赖于参数。有很多人是通过训练数据的交叉验证来寻找合适的参数，不过这个过程比较耗时。  
**多项式核函数**：$K(x_1,x_2)=(x_1\cdot x_2+1)^p$  
**字符串核函数**：在文本分类、信息检索、生物信息学等方面有应用。  
应用场景：特征维数高选择线性核；样本数量可观、特征少选择高斯核；样本数量非常多选择线性核（避免造成庞大的计算量）。
## 序列最小最优化算法 (SMO)
整个 SMO 算法包括两个部分：求解两个变量二次规划的解析方法和选择变量的启发式方法。  
是支持向量机学习的一种快速算法，其特点是不断地将原二次规划问题分解为只有两个变量的二次规划子问题，并对子问题进行解析求解，直到所有变量满足 KKT 条件。这样通过启发式的方法得到原二次规划问题的最优解。因为子问题有解析解，所以每次计算子问题都很快，虽然计算子问题次数很多，但在整体上还是高效的。
## 总结
**优点**：  
(1) 解决高维特征的分类问题和回归问题很有效，在特征维度大于样本数时依然有很好的效果。  
(2) 仅仅使用一部分支持向量来做超平面的决策，无需依赖全部数据。  
(3) 有大量的核函数可以使用，从而可以很灵活的来解决各种非线性的分类回归问题。  
(4) 样本量不是海量数据的时候，分类准确率高，泛化能力强。  
**缺点**：  
(1) 如果特征维度远远大于样本数，则SVM表现一般。  
(2) SVM在样本量非常大，核函数映射维度非常高时，计算量过大，不太适合使用。  
(3) 非线性问题的核函数的选择没有通用标准，难以选择一个合适的核函数。  
(4) SVM对缺失数据敏感。
# 逻辑回归 (logistic regressive)  
[线性回归原理小结](https://www.cnblogs.com/pinard/p/6004041.html)  
[逻辑回归算法面经](https://zhuanlan.zhihu.com/p/46591702)  
[LR与SVM的异同](https://www.cnblogs.com/zhizhan/p/5038747.html)  
[SVM和logistic回归分别在什么情况下使用？](https://www.zhihu.com/question/21704547/answer/20293255)  
逻辑回归是统计学习方法中的经典分类方法；最大熵是概率模型学习的一个准则，将其推广到分类问题得到最大熵模型。逻辑回归和最大熵模型都属于对数线性模型，两者模型的学习一般采用极大似然估计，或正则化的极大似然估计，求解该最优化问题的算法有改进的迭代尺度法、梯度下降法、拟牛顿法。  
二项逻辑回归是一种分类模型，由条件概率分布 $P(Y|X)$ 表示，随机变量 $X$ 取实数，$Y$ 取值1或0。
## 模型
$$P(Y=1|x)=\frac{\exp(w\cdot x)}{1+\exp(w\cdot x)}$$
$$P(Y=0|x)=\frac{1}{1+\exp(w\cdot x)}$$
一个事件发生的几率 (odds) 指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率是 $p$，则该事件的对数几率或 logit 函数为：$\text{logit}(p)=\log\frac{p}{1-p}$。对逻辑回归而言，$\log\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\cdot x$。
## 模型参数估计
给定数据集，$x_i\in R^n$，$y_i\in\{0,1\}$，使用极大似然估计法估计模型参数，从而得到逻辑回归模型。设：  
$$P(Y=1|x)=\pi(x), \quad\quad P(Y=0|x)=1-\pi(x)$$
似然函数为：
$$\prod_{i=1}^{N}[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}$$
对数似然函数为：
$$\begin{aligned}
L(w)&=\sum_{i=1}^{N}[y_i\log\pi(x_i)+(1-y_i)\log(1-\pi(x_i))] \newline  
&=\sum_{i=1}^{N}\left[y_i\log\frac{\pi(x_i)}{1-\pi(x_i)}+\log(1-\pi(x_i))\right] \newline  
&=\sum_{i=1}^{N}[y_i(w\cdot x_i)-\log(1+\exp(w\cdot x_i))]
\end{aligned}$$
对 $L(w)$ 求极大值，得到 $w$ 的估计值。梯度下降或拟牛顿法。  
梯度下降：  
$$\frac{\partial L}{\partial w}=\sum_{i=1}^{N}(y_ix_i-\pi(x_i)x_i)\quad\rightarrow\quad w=w+\eta(y_i-\pi(x_i))x_i$$
## 多项逻辑回归
$Y$ 的取值集合为 $\{1,2,\cdots, K\}$，多项逻辑回归模型为：
$$P(Y=k|x)=\frac{\exp(w_k\cdot x)}{1+\sum_{i=1}^{K-1}\exp(w_i\cdot x)},\quad k=1,2,\cdots,K-1$$
$$P(Y=K|x)=\frac{1}{1+\sum_{i=1}^{K-1}\exp(w_i\cdot x)}$$
# 最大熵模型 (maximum entropy model)
## 最大熵原理
离散随机变量 $X$ 的概率分布是 $P(X)$，则其熵为：
$$H(P)=-\sum_{x}P(x)\log P(x)$$  
随机变量 $X$ 给定的条件下随机变量 $Y$ 的条件熵：
$$H(Y|X)=\sum_{x}P(x)H(Y|X=x)$$  
熵满足不等式：$0\leq H(P)\leq\log |X|$，$|X|$ 是 $X$ 取值的个数，当且仅当 $X$ 的分布是均匀分布时右边等号成立，熵最大。  
最大熵原理是概率模型学习的一个准则，认为，学习概率模型时，在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。
## 最大熵模型
最大熵模型可以由最大熵原理推导得出，最大熵原理应用到分类模型的学习中，得到一个约束最优化问题，求解此最优化问题的对偶问题得到最大熵模型。  
最大熵模型可用于二类或多类分类，由以下条件概率分布表示：  
$$P_w(y|x)=\frac{1}{Z_w(x)}\exp(\sum_{i=1}^{n}w_i f_i(x,y))$$
$$Z_w(x)=\sum_y\exp(\sum_{i=1}^{n}w_i f_i(x,y))$$
$Z_w(x)$ 是规范化因子，$f_i$ 为特征函数，$w_i$ 为特征的权值。  
## 总结
**优点**：  
(1) 最大熵统计模型获得的是所有满足约束条件的模型中信息熵极大的模型，作为经典的分类模型时准确率较高。  
(2) 可以灵活地设置约束条件，通过约束条件的多少可以调节模型对未知数据的适应度和对已知数据的拟合程度。  
**缺点**：  
由于约束函数数量和样本数目有关系，导致迭代过程计算量巨大，实际应用比较难。
# k近邻 (k-NN)
基本的分类与回归方法。输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k近邻法假设给定一个训练数据集，其中的实例类别已定，分类时，对新的实例，根据其 $k$ 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻法不具有显示的学习过程，实际上利用训练数据集对特征向量空间进行划分，并作为其分类的模型。$k$ 值的选择、距离度量、分类决策规则是k近邻法的三个基本要素。  
**$k$ 值的选择**：通常使用交叉验证法来选取最优的值。  
$k$ 值减小，整体模型变得复杂，容易发生过拟合，近似误差减小，估计误差增大；  
$k$ 值增大，整体模型变得简单，估计误差减小，近似误差增大。  
**距离度量**：  
$L_p$ 距离 (Minkowski 距离)：$p\geq1$。  
$p=1$：曼哈顿距离；$p=2$：欧氏距离距离；$p=\infty$：切比雪夫距离。  
**分类决策规则**：往往是多数表决，多数表决规则等价于经验风险最小化。  
k近邻法的实现需要考虑如何快速搜索 $k$ 个最近邻点。kd树是一种便于对 $k$ 维空间中的数据进行快速检索的数据结构，是二叉树，表示对 $k$ 维空间的一个划分，其每个结点对应于 $k$ 维空间划分中的一个超矩形区域。利用kd树可以省去对大部分数据点的搜索，从而减少搜索的计算量。
# 聚类算法
常见的距离度量：欧氏距离、曼哈顿距离、切比雪夫距离、余弦距离。  
[K-Means聚类算法原理](https://www.cnblogs.com/pinard/p/6164214.html)  
[BIRCH聚类算法原理](https://www.cnblogs.com/pinard/p/6179132.html)  
[DBSCAN密度聚类算法](https://www.cnblogs.com/pinard/p/6208966.html)  
[谱聚类（spectral clustering）原理总结](https://www.cnblogs.com/pinard/p/6221564.html)  
# 朴素贝叶斯
基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率密度；然后基于此模型，对给定的输入 $x$，利用贝叶斯定理求出后验概率最大的输出 $y$。朴素贝叶斯法实现简单，学习与预测的效率都很高，但分类的准确率不一定高。  
## 基本方法 
先验概率分布：$P(Y=c_k),\quad k=1,2,\cdots, K$  
条件概率分布：$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},\cdots, X^{(n)}=x^{(n)}|Y=c_k),\quad k=1,2,\cdots, K$  
朴素贝叶斯法对条件概率分布作了条件独立性的假设，即：  
$$\begin{aligned}
P(X=x|Y=c_k)&=P(X^{(1)}=x^{(1)},\cdots, X^{(n)}=x^{(n)}|Y=c_k) \newline  
&=\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)
\end{aligned}$$  
从而学习到联合概率分布 $P(X,Y)$。  
## 参数估计
用**极大似然估计**法估计相应的概率。  
先验概率 $P(Y=c_k)$ 的极大似然估计：
$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)}{N}$$
条件概率 $P(X^{(j)}=a_{jl}|Y=c_k)$ 的极大似然估计：  
$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^{N}I(y_i=c_k)}$$
用极大似然估计可能会出现所要估计的概率值为0的情况，这时会影响到后验概率的计算结果，使分类产生偏差，解决方法是采用**贝叶斯估计**。$\lambda\geq0$，$\lambda=1$ 时称为拉普拉斯平滑。  
$$P_\lambda(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)+\lambda}{N+K\lambda}$$
$$P_\lambda(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k)+\lambda}{\sum_{i=1}^{N}I(y_i=c_k)+S_j\lambda}$$
**分类时**，对给定的输入 $x$，通过学习到的模型计算后验概率分布 $P(Y=c_k|X=x)$，将后验概率最大的类作为 $x$ 的类输出。后验概率的计算根据贝叶斯定理进行：  
$$\begin{aligned}
P(Y=c_k|X=x)&=\frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_{k}P(X=x|Y=c_k)P(Y=c_k)} \newline  
&=\frac{P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_{k}P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)}
\end{aligned}$$  
从而朴素贝叶斯分类器可以表示为：
$$y=\text{argmax}_{c_k}P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)$$
后验概率最大化等价于0-1损失函数时的期望风险最小化。
# EM算法
[EM算法原理总结](https://www.cnblogs.com/pinard/p/6912636.html)  
期望极大算法，简称EM算法，是一种迭代算法，用于含有隐变量的概率模型参数的极大似然估计，或极大后验概率估计。  
观测变量数据 $Y$，隐变量数据 $Z$，EM算法通过迭代求 $L(\theta)=\log P(Y|\theta)$ 的极大似然估计，每次迭代包含两步：E步，求期望；M步，求极大化。  
1.选择参数的初值 $\theta^{(0)}$，开始迭代；  
2.E步：记 $\theta^{(i)}$ 为第 $i$ 次迭代参数 $\theta$ 的估计值，在第 $i+1$ 次迭代的E步，计算：  
$$\begin{aligned}
Q(\theta,\theta^{(i)})&=E_z[\log P(Y,Z|\theta)|Y,\theta^{(i)}] \newline  
&=\sum_{z}\log P(Y,Z|\theta)P(Z|Y,\theta^{(i)})
\end{aligned}$$  
3.M步：求使 $Q(\theta,\theta^{(i)})$ 极大化的 $\theta$，确定第 $i+1$ 次迭代的参数的估计值 $\theta^{(i+1)}$：  
$$\theta^{(i+1)}=\text{argmax}_\theta Q(\theta,\theta^{(i)})$$  
4.重复第2步和第3步，直到收敛。  
$Q(\theta,\theta^{(i)})$ 是EM算法的核心，称为 $Q$ 函数，为完全数据的对数似然函数 $\log P(Y,Z|\theta)$ 关于在给定观测数据 $Y$ 和当前参数 $\theta^{(i)}$ 下对未观测数据 $Z$ 的条件概率分布 $P(Z|Y,\theta^{(i)})$ 的期望。  
EM算法的优点是简单性和普适性。一般条件下是收敛的，但不能保证收敛到全局最优。  
对初值是敏感的，在应用中，选取几个不同的初值进行迭代，然后对得到的各个估计值加以比较，从中选择最好的。  
EM算法可以用于生成模型的非监督学习，生成模型由联合概率分布 $P(X,Y)$ 表示，可以认为非监督学习训练数据是联合概率分布产生的数据，$X$ 是观测数据，$Y$ 是未观测数据。  
EM算法的应用：高斯混合模型的参数估计、隐马尔可夫模型的非监督学习。  
# 高斯混合模型
[高斯混合模型（GMM）](https://blog.csdn.net/m_buddy/article/details/80432384)  
聚类算法
# 隐马尔可夫模型 (HMM)
隐马尔可夫模型是关于时序的概率模型，描述由一个隐藏的马尔可夫链随机生成不可观测的状态的序列，再由各个状态随机生成一个观测而产生观测的序列的过程。由初始状态概率向量 $\pi$、状态转移概率矩阵 $A$ 和观测概率矩阵 $B$ 决定。因此，隐马尔可夫模型可以写成 $\lambda=(A,B,\pi)$。  
是一个生成模型，表示状态序列和观测序列的联合分布，但是状态序列是隐藏的，不可观测的。  
是可用于标注问题的统计学习模型，这时状态对应着标记，标注问题是给定观测序列预测其对应的标记序列。  
在语音识别、自然语言处理、生物信息、模式识别等领域有着广泛的应用。  
## 概率计算算法
给定模型 $\lambda=(A,B,\pi)$ 和观测序列 $O=(o_1,o_2,\cdots,o_T)$，计算在模型 $\lambda$ 下观测序列 $O$ 出现的概率 $P(O|\lambda)$。  
前向-后向算法是通过递推地计算前向-后向概率可以高效地进行隐马尔可夫模型的概率计算。  
## 学习算法
已知观测序列 $O=(o_1,o_2,\cdots,o_T)$，估计模型 $\lambda=(A,B,\pi)$ 参数，使得在该模型下观测序列概率 $P(O|\lambda)$ 最大，即用极大似然估计的方法估计参数。Baum-Welch算法，也就是EM算法可以高效地对隐马尔可夫模型进行训练，它是一种非监督学习算法。
## 预测算法
也称为解码问题，已知模型 $\lambda=(A,B,\pi)$ 和观测序列 $O=(o_1,o_2,\cdots,o_T)$，求对给定观测序列条件概率 $P(I|O)$ 最大的状态序列 $I=(i_i,i_2,\cdots,i_T)$，即给定观测序列，求最有可能的对应的状态序列。  
隐马尔可夫模型预测的两种算法：近似算法与维特比算法。  
近似算法的优点是计算简单，缺点是不能保证预测的状态序列整体是最有可能的状态序列。  
维特比算法应用动态规划高效地求解最优路径，即概率最大的状态序列。
# 条件随机场 (CRF)
[条件随机场CRF(一)从随机场到线性链条件随机场](https://www.cnblogs.com/pinard/p/7048333.html)  
[如何轻松愉快地理解条件随机场（CRF）？](https://www.jianshu.com/p/55755fc649b1)  
[HMM、MEMM vs CRF 对比？](https://zhuanlan.zhihu.com/p/57153934)
## 概率无向图模型
又称马尔可夫随机场 (MRF)，是一个可以由无向图表示的联合概率分布。无向图上的结点之间的连接关系表示了联合分布的随机变量集合之间的条件独立性，即马尔可夫性。  
设有联合概率分布 $P(Y)$，由无向图 $G=(V,E)$ 表示，在图 $G$ 中，结点表示随机变量，边表示随机变量之间的依赖关系。如果联合概率分布 $P(Y)$ 满足成对、局部或全局马尔可夫性，就称此联合概率分布为概率无向图模型或马尔可夫随机场。    
因子分解：概率无向图模型的联合概率分布可以分解为无向图中所有最大团上的正值函数的乘积的形式。
## 条件随机场
是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫随机场。即，条件随机场是给定随机变量 $X$ 条件下，随机变量 $Y$ 的马尔可夫随机场。    
条件随机场可以用于不同的预测问题，如标注问题。  
**线性链条件随机场**：由输入序列对输出序列预测的判别模型，一般表示为给定观测序列条件下的标记序列的条件概率分布，形式为参数化的对数线性模型，其学习方法通常是极大似然估计或正则化的极大似然估计。  
模型包括特征及相应的权值，特征是定义在线性链的边与结点上的，数学表达式：
$$P(y|x)=\frac{1}{Z(x)}\exp(\sum_{i,k}\lambda_k t_k(y_{i-1},y_i,x,i)+\sum_{i,l}\mu_l s_l(y_i,x,i))$$
$$Z(x)=\sum_y\exp(\sum_{i,k}\lambda_k t_k(y_{i-1},y_i,x,i)+\sum_{i,l}\mu_l s_l(y_i,x,i))$$  
## 条件随机场的概率计算问题
给定条件随机场 $P(Y|X)$，输入序列 $x$ 和 输出序列 $y$，计算条件概率 $P(Y_i=y_i|x)$，$P(Y_{i-1}=y_{i-1},Y_i=y_i|x)$ 以及相应的数学期望。使用前向-后向算法递归地计算。  
## 条件随机场的学习算法
给定训练数据集估计条件随机场模型的参数，条件随机场模型实际上是定义在时序数据上的对数线性模型，其学习方法包括极大似然估计和正则化的极大似然估计，具体的优化实现算法有改进的迭代尺度法、梯度下降法、拟牛顿法。  
## 条件随机场的预测算法
给定条件随机场 $P(Y|X)$ 和输入序列（观测序列） $x$，求条件概率最大的输出序列（标记序列）$y^{\star}$，即对观测序列进行标注，使用维特比算法。
# 决策树
[决策树算法原理(下)](https://www.cnblogs.com/pinard/p/6053344.html)  
基本的分类与回归方法。决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是 if-then 规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。主要优点是模型具有可读性，分类速度快。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。  
决策树学习本质上是从训练数据集中归纳出一组分类规则，旨在构建一个与训练数据拟合很好，并且复杂度小的决策树。损失函数通常是正则化的极大似然函数，而从所有可能的决策树中选取最优决策树是 NP 完全问题，现实中采用启发式方法，近似求解这一最优化问题。  
## 特征选择
特征选择在于选取对训练数据具有分类能力的特征。 
### 熵 
熵表示随机变量不确定性的度量。设 $X$ 是一个取有限个值的离散随机变量，其概率分布为 $P(X=x_i)=p_i,\quad i=1,2,\cdots,n$，则随机变量 $X$ 的熵定义为：
$$H(p)=H(X)=-\sum_{i=1}^{n}p_i\log p_i$$
设随机变量 $(X,Y)$，条件熵 $H(Y|X)$ 表示在已知随机变量 $X$ 的条件下随机变量 $Y$ 的不确定性，定义为 $X$ 给定条件下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望：
$$H(Y|X)=\sum_{i=1}^{n}p_iH(Y|X=x_i)$$
### 信息增益
信息增益表示得知特征 $X$ 的信息而使得类 $Y$ 的信息的不确定性减少的程度。特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$，定义为集合 $D$ 的经验熵与特征 $A$ 给定条件下 $D$ 的经验条件熵之差：  
$$g(D,A)=H(D)-H(D|A)$$
$$H(D)=-\sum_{k=1}^{K}\frac{|C_k|}{|D|}\log\frac{|C_k|}{|D|}$$
$$H(D|A)=-\sum_{i=1}^{n}\frac{|D_i|}{|D|}\sum_{k=1}^{K}\frac{|D_{ik}|}{|D_i|}\log\frac{|D_{ik}|}{|D_i|}$$
### 信息增益比
以信息增益作为划分训练数据集的特征，偏向于选择取值较多的特征。特征 $A$ 对训练数据集 $D$ 的信息增益比 $g_R(D,A)$ 定义为其信息增益与训练数据集 $D$ 关于特征 $A$ 的值的熵之比：
$$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$$
$$H_A(D)=-\sum_{i=1}^{n}\frac{|D_i|}{|D|}\log\frac{|D_i|}{|D|}$$
### 基尼指数
分类问题中，假设有 $K$ 个类，样本点属于第 $k$ 类的概率为 $p_k$，则概率分布的基尼指数定义为：
$$\text{Gini}(p)=\sum_{k=1}^{K}p_k(1-p_k)=1-\sum_{k=1}^{K}{p_k}^2$$
对于给定的样本集合 $D$，其基尼指数为：
$$\text{Gini}(D)=1-\sum_{k=1}^{K}(\frac{|C_k|}{|D|})^2$$
如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为：
$$\text{Gini}(D,A)=\frac{|D_1|}{|D|}\text{Gini}(D_1)+\frac{|D_2|}{|D|}\text{Gini}(D_2)$$
基尼指数 $\text{Gini}(D)$ 表示集合 $D$ 的不确定性，基尼指数 $\text{Gini}(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越大。  
CART分类树通过基尼指数选择最优特征，同时决定该特征的最优二值切分点。
## 决策树的生成
通常使用信息增益最大 (ID3)、信息增益比最大 (C4.5)、基尼指数最小 (CART) 作为特征选择的准则。通过计算上述指标，从根结点开始，递归地产生决策树。这相当于用上述准则不断地选取局部最优的特征，或将训练集分割为能够基本正确分类的子集。  
ID3算法只有树的生成，所以该算法生成的树容易产生过拟合。
## 决策树的剪枝
剪枝：在决策树学习中将已生成的树进行简化的过程，从已生成的树上剪掉一些叶节点或叶结点以上的子树，并将其父结点或根结点作为新的叶结点。通过极小化决策树整体的损失函数来实现。
$$C_\alpha(T)=C(T)+\alpha|T|$$
$C(T)$ 表示模型对训练数据的预测误差，$|T|$ 表示模型复杂度，$\alpha\geq0$，较大的 $\alpha$ 促使选择较简单的树，较小的 $\alpha$ 促使选择较复杂的树，$\alpha=0$ 不考虑模型的复杂度。  
比较一组叶结点回缩到其父结点之前和之后的整体树对应的损失函数值。  
决策树生成学习局部的模型，决策树剪枝学习整体的模型。
## 分类与回归树 (CART)
CART可用于分类与回归。假设决策树是二叉树，内部结点特征的取值为“是”和“否”，左分支是取值为“是”的分支，右分支是取值为“否”的分支。这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。  
CART，对回归树用平方误差最小化准则，对分类树用基尼指数最小化准则，进行特征选择，生成二叉树。   
# 提升方法 (boosting)
[集成学习概述](https://www.cnblogs.com/pinard/p/6131423.html)  
提升方法是将弱学习算法提升为强学习算法的统计学习方法。在分类学习中，提升方法通过反复修改训练数据的权值分布，构建一系列基本分类器（弱分类器），并将这些基本分类器线性组合，构成一个强分类器。
## AdaBoost
AdaBoost算法的特点是通过迭代每次学习一个基本分类器。每次迭代中，提高那些被前一轮分类器错误分类数据的权值，而降低那些被正确分类的数据的权值。最后，AdaBoost将基本分类器的线性组合作为强分类器，其中给分类误差率小的基本分类器以大的权值，给分类误差率大的基本分类器以小的权值。
$$f(x)=\sum_{m=1}^{M}\alpha_mG_m(x)$$
AdaBoost的每次迭代可以减少它在训练数据集上的分类误差率，这说明了它作为提升方法的有效性。  
AdaBoost算法的一个解释是该算法实际是前向分步算法的一个实现，在这个方法里，模型是加法模型，损失函数是指数函数，算法是前向分步算法。
## 提升树
提升树是以分类树或回归树为基本分类器的提升方法，被认为是统计学习中性能最好的方法之一。  
提升方法实际采用加法模型（即基函数的线性组合）与前向分步算法。  
针对不同问题的提升树学习算法：  
1.用指数损失函数的二类分类问题：此时的提升树算法是AdaBoost算法的特殊情况。  
2.用平方误差损失函数的回归问题：前向分步算法，拟合当前模型的残差。  
3.用一般损失函数的一般决策问题：梯度提升算法。  
**梯度提升决策树 (GBDT)**：  
利用梯度下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树。  
1.初始化：  
$$f_0(x)=\text{argmin} \sum_{i=1}^{N}L(y_i,c)$$
2.对 $m=1,2,\cdots,M$  
(a) 对 $i=1,2,\cdots,N$，计算：  
$$r_{mi}=-\left[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}\right]_{f(x)=f_{m-1}(x)}$$  
(b) 对 $r_{mi}$ 拟合一个回归树，得到第 $m$ 棵树的叶结点区域 $R_{mj}$  
(c) 对 $j=1,2,\cdots,J$，计算：  
$$c_{mj}=\text{argmin}_c\sum_{x_i \in R_{mj}}L(y_i,f_{m-1}(x_i)+c)$$  
(d) 更新：  
$$f_m(x)=f_{m-1}(x)+\sum_{j=1}^{J}c_{mj}I(x\in R_{mj})$$  
3.得到回归树：  
$$\hat{f}(x)=f_M(x)=\sum_{m=1}^{M}\sum_{j=1}^{J}c_{mj}I(x \in R_{mj})$$  
算法第1步初始化，估计使损失函数极小化的常数值，它是只有一个根结点的树。第2(a)步计算损失函数的负梯度在当前模型的值，将它作为残差的估计。对于平方损失函数，它就是通常所说的残差，对于一般损失函数，它就是残差的近似值。第2(b)步估计回归树叶结点区域，以拟合残差的近似值。第2(c)步利用线性搜索估计叶结点区域的值，使损失函数最小化。第2(d)步更新回归树。第3步得到输出的最终模型。
## XGBoost 和 lightGBM
[XGBoost算法原理小结](https://www.cnblogs.com/pinard/p/10979808.html)  
[RF、GBDT、XGBoost、lightGBM原理与区别](https://blog.csdn.net/data_scientist/article/details/79022025)  
# Bagging和随机森林(RF)
[Bagging与随机森林算法原理小结](https://www.cnblogs.com/pinard/p/6156009.html)  
[Bagging和Boosting 概念及区别](https://www.cnblogs.com/liuwu265/p/4690486.html)  
# 降维
## 奇异值分解 (SVD)
[奇异值分解(SVD)原理与在降维中的应用](https://www.cnblogs.com/pinard/p/6251584.html)  
**特征分解**：  
$$A[w_1,w_2,\cdots,w_n]=[w_1,w_2,\cdots,w_n]\Sigma$$
$\Sigma$ 为这 $n$ 个特征值为主对角线的 $n\times n$ 维矩阵。若 $w_1,w_2,\cdots,w_n$ 线性无关，则
$$A=W\Sigma W^{-1}$$  
对于 $n\times n$ 的实对称矩阵 $A$ ，有 $n$ 个特征值 $\lambda_1\leq\lambda_2\leq\cdots\leq\lambda_n$，及对应的特征向量 $\{w_1,w_2,\cdots,w_n\}$，可正交相似对角化。对特征向量标准化后，这 $n$ 个特征向量为标准正交基，满足 $W^TW=I$，即 $W$ 为酉矩阵，则  
$$A=W\Sigma W^{T}$$  
**SVD**：  
$$A_{m \times n} = U_{m \times m}\Sigma_{m \times n} V_{n \times n}^T$$
$U$ 和 $V$ 都是酉矩阵，$V$ 由 $A^TA$ 的所有特征向量组成，$U$ 由 $AA^T$ 的所有特征向量组成，奇异值 $\sigma_i = \sqrt{\lambda_i}$，$\lambda_i$ 为 $A^TA$ 的非0特征值， $A^TA$ 和  $AA^T$ 的非0特征值相同。  
奇异值跟特征分解中的特征值类似，在奇异值矩阵中也是按照从大到小排列，而且奇异值的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上的比例。也就是说，可以用最大的 $k$ 个的奇异值和对应的左右奇异向量来近似描述矩阵。
$$A_{m \times n} = U_{m \times m}\Sigma_{m \times n} V_{n \times n}^T\approx U_{m \times k}\Sigma_{k \times k} V_{n \times k}^T$$
## 主成分分析 (PCA)
[PCA的数学原理](http://blog.codinglabs.org/articles/pca-tutorial.html)  
[主成分分析（PCA）原理总结](https://www.cnblogs.com/pinard/p/6239403.html)  
[典型关联分析(CCA)原理总结](https://www.cnblogs.com/pinard/p/6288716.html)  
PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。最小投影距离或最大投影方差，算法流程：  
输入为 $m$ 个 $n$ 维的样本 $X_{n\times m}$，降到 $k$ 维。  
(1) 对所有样本进行中心化：$X_{n\times m}-=\mu_{n\times1}$  
(2) 计算样本的协方差矩阵 $XX^T$  
(3) 对 $XX^T$ 进行特征值分解：$XX^T=W\Sigma W^T$  
(4) 取出最大的 $k$ 个特征值对应的特征向量 $w_1,w_2,\cdots,w_k$，将所有的特征向量标准化后，组成特征向量矩阵 $P$  
(5) 对样本集中的每一个样本 $x$，转化成新的样本 $z=P^Tx$  
(6) 得到输出样本集 $Z_{k\times m}$  
CCA先将高维数据降到1维，然后再用相关系数进行相关性的分析。
## 线性判别分析 (LDA)
[线性判别分析LDA原理总结](https://www.cnblogs.com/pinard/p/6244265.html)  
监督学习的降维技术，投影后类内方差最小，类间方差最大。  
LDA和PCA相同点：  
(1) 两者均可以对数据进行降维；  
(2) 两者在降维时均使用了矩阵特征分解的思想；  
(3) 两者都假设数据符合高斯分布。  
不同点：  
(1) LDA是有监督的降维方法，而PCA是无监督的降维方法；  
(2) LDA降维最多降到类别数 $k-1$ 的维数，而PCA没有这个限制；  
(3) DA除了可以用于降维，还可以用于分类；  
(4) LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。
## 局部线性嵌入 (LLE)
[局部线性嵌入(LLE)原理总结](https://www.cnblogs.com/pinard/p/6266408.html)  
属于流形学习的一种，关注于降维时保持样本局部的线性特征，广泛用于图像识别，高维数据可视化等领域。  
LLE算法主要分为三步，第一步是求K近邻的过程，使用了和KNN算法一样的求最近邻的方法；第二步，就是对每个样本求它在邻域里的K个近邻的线性关系，得到线性关系权重系数 $W$；第三步就是利用权重系数来在低维里重构样本数据。
# 其他问题
## 生成模型与判别模型
监督学习的任务就是学习一个模型，应用这一模型，对给定的输入预测相应的输出。这个模型的一般形式为决策函数：$Y=f(X)$，或者条件概率分布：$P(Y|X)$。  
监督学习方法又可以分为生成方法和判别方法，所学到的模型分别称为生成模型和判别模型。  
生成方法由数据学习联合概率分布$P(X,Y)$，然后求出条件概率分布$P(Y|X)$作为预测的模型，即生成模型：$P(Y|X)=\frac{P(X,Y)}{P(X)}$。典型的生成模型有：***朴素贝叶斯、隐马尔可夫模型 (HMM)、高斯混合模型、隐含狄利克雷分布 (LDA)***。**优点**：可以还原出联合概率分布${P(X,Y)}$；学习收敛速度更快；当存在隐变量时，仍可以用生成方法学习，而不能用判别方法。  
判别方法由数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。典型的判别模型有：***k近邻法、感知机、决策树、逻辑回归、线性回归、最大熵模型、支持向量机 (SVM)、提升方法 (boosting)、条件随机场 (CRF)、神经网络、线性判别分析 (LDA)***。直接学习决策函数或条件概率，**优点**：直接面对预测，往往学习的准确率更高；可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。
## 特征工程
[特征工程之特征选择](https://www.cnblogs.com/pinard/p/9032759.html)  
[特征工程之特征表达](https://www.cnblogs.com/pinard/p/9061549.html)  
[特征工程之特征预处理](https://www.cnblogs.com/pinard/p/9093890.html)
## 最小二乘法
[最小二乘法小结](https://www.cnblogs.com/pinard/p/5976811.html)
## 交叉验证
[交叉验证(Cross Validation)原理小结](https://www.cnblogs.com/pinard/p/5992719.html)